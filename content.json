[{"title":"this指针详解","date":"2017-04-12T14:41:36.000Z","path":"2017/04/12/this指针详解/","text":"我们知道在如下例子中。class Test{public: Fun(int a) { //doSomething }private: int a;};Fun(int a)是Test的非静态成员函数，所以编译器在编译期间改写该函数时，会自动将一个名为this的指针当作为第一个参数传入。类&#20284;于：Fun(Test const this，int a);那么问题来了，我们理解这个this指针呢？它有哪些用法和限制呢？本文试图通过如下几个模块循环渐进的解析this指针，争取达到深入浅出的效果。1，this指针是什么？2，this指针的六大属性。3，this指针的一些用法。4，this指针的注意事项。1，this指针是什么？关于this指针超级经典的一段话：当你进入一个房子后， 你可以看见桌子、椅子、地板等， 但是房子你是看不到全貌了。 对于一个类的实例来说， 你可以看到它的成员函数、成员变量， 但是实例本身呢？ this是一个指针，它时时刻刻指向你这个实例本身。2，this指针的六大属性。我一直都认为若想对某一变量有个准确的认知，就必须了解其六大属性。（我的以前博客中有所介绍点击打开链接）这些属性是我们对于this指针应该以何种方式正确使用的基础。（1）名称属性：标识符this表示。（2）类型属性：类类型 const（类&#20284;于类引用的类型）（3）&#20540;属性：表示当前调用该函数对象的首地址。（4）作用域：this指针是编译器默认传给类中非静态函数的隐含形参，所以其作用域在非静态成员函数的函数体内。（5）链接属性：在该类作用域中，不同类的非静态成员函数中，this这个指针变量的链接属性是内部的，但其所指对象是外部的，即this变量是不同的实体，但指向对象是同一个。（6）存储类型：this指针是由编译器生成，当类的非静态成员函数的参数个数一定时，this指针存储在ecx寄存器中；若该函数参数个数未定（可变参数函数），则存放在栈中。3，this指针的一些用法。（1）作为当前类的指针，用来区别形参和成员变量名称相同的情况。比如本文开头的例子，在Test::Test(int a)函数的作用域中，形参a与类的成员变量a同名，则形参a会将成员变量a隐藏。我们无法直接访问成员变量a，除了在a前面加上类的名字如Test::a来表示类Test的成员变量a外，还可以显示使用this指针来强制访问对象成员this-&gt;a（2）this作为返回&#20540;，返回当前对象的引用。在赋&#20540;运算符重载函数中，为了不减少赋&#20540;运算符的功能，我们需要返回一个引用，来支持重复赋&#20540;（例如a = b =c;）同样，在类的赋&#20540;运算符重载函数中，我们可以一般使用(this)作为当前对象返回。4，this指针的注意事项。（1）this指针不能为空。因为this指向一个已存在的类的实例对象，可以通过&quot;-&gt;&quot;的方式，访问类中成员，左移this为空是非法的。例如，在本文开头例子中，将成员变量a的访问权限改写为public，然后执行下面代码，虽然编译会通过，但程序运行会崩溃。 Test pT = NULL; pT-&gt;a = 10;（2）为什么使用的是指针，而不是引用。this指针的类型和类引用的类型都是Test* const但是，由于历史原因，C&#43;&#43;最初是没有引用，而有指针的，在设计类时，就采用了指针的方式，就导致了现在的局面。虽然引用理论上也可以实现this的功能。（3）this指针并不是对象的一部分，不影响sizeof的结果。（4）this指针是由编译器自动生成，作为函数的第一个参数，用户不能显示传递。（5）this指针不能在构造函数的初始化列表中给对象的成员变量赋&#20540;，初始化列表本义是在创建类的实例对象时，给其中成员变量赋初&#20540;。即此时对象还未创建完毕。而this指针是类在创建之后，由编译器自动生成的指针，指向对象的首地址。简单来说，先有对象，后有this指针。所以this指针不能在初始化列表中给成员指针赋初&#20540;。（6）关于this的存储及传参顺序当类的非静态成员函数的参数个数是一定时，this指针存储在ecx寄存器上，通过ecx传递给调用者，此时函数调用约定是_thiscall。若参数个数不确定（可变参数）时，则借助栈，在所有的参数被压栈后，再压入栈中，此时函数调用约定是_cdecl。示例：将Test类简化，只声明，不定义。（可以方便的观察函数的调用约定和函数名的改写）class Test{public: void Fun(int a);};其中，Fun(int a)的个数确定，只有一个。则链接时会报错：error LNK2019: 无法解析的外部符号 &quot;public: void thiscall Test::Fun(int)&quot; (?Fun@Test@@QAEXH@Z)，该符号在函数 _main 中被引用将void Fun(int a);改为void Fun(…);则链接时报错为：error LNK2019: 无法解析的外部符号 &quot;public: void cdecl Test::Fun(…)&quot; (?Fun@Test@@QAAXZZ)，该符号在函数 _main 中被引用可以证明，当函数参数不同时，函数的调用约定不同，this的存储类型不同，造成了其传参顺序的不同。","tags":[]},{"title":"","date":"2017-04-11T15:07:32.807Z","path":"2017/04/11/test/","text":"","tags":[]},{"title":"第一篇博客","date":"2017-04-10T09:12:49.000Z","path":"2017/04/10/第一篇博客/","text":"","tags":[]},{"title":"hello world2","date":"2017-04-09T13:51:32.000Z","path":"2017/04/09/hello-world2/","text":"","tags":[]},{"title":"hello world","date":"2017-04-09T13:51:00.000Z","path":"2017/04/09/hello-world-1/","text":"","tags":[]},{"title":"Hello World","date":"2017-04-09T12:53:22.938Z","path":"2017/04/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]