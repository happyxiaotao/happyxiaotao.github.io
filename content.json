[{"title":"","date":"2017-08-16T09:56:02.735Z","path":"2017/08/16/元素入栈出栈的合法性检测/","text":"题目描述：元素出栈、入栈顺序的合法性。如：入栈的序列（1,2,3,4,5），出栈序列为（4,5,3,2,1），则合法。入栈的序列（1,2,3,4,5），出栈序列为（4,5,2,3,1），则不合法。 难点分析：在出栈、入栈操作随机性比较强，不好把握它们的动态变换。但是，要牢记栈的性质“后进先出”。第一个出栈的元素，肯定是当时栈空间中元素中最后进入的。即使，后来又有新的元素入栈，但是我们知道它们的入栈顺序，和出栈顺序，就可以模拟出，当时元素入栈、出栈的情况。 思路：可以利用一个辅助的栈空间。1，把第一个序列v1中的数字逐个压入栈中，压入的过程中把第二个序列v2中元素与栈首元素比较。2，如果相同，则出栈，同时,v2下标往后移，准备进行下一次比较。3，如果不同，则将v1中数据依次入栈，直到满足1中的条件或者没有数据为止。 实现代码：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;bool Check_Out_Stack_Order(const vector&lt;T&gt;&amp; v_1, const vector&lt;T&gt; v_2)&#123; //两个序列个数不相同 if (v_1.size() != v_2.size()) return false; //此时v_1,v_2中元素个数肯定相同 stack&lt;T&gt; s; //辅助栈，造成v_2序列的栈，这里称为原栈 size_t index_1 = 0; //作为v_1的下标 size_t index_2 = 0; //作为v_2的下标 while (index_2 &lt; v_2.size()) //包含了v_1,v_2都为空的情况 &#123; //当s为空,或辅助栈顶元素不等于v_2[index_2]时，v_1中元素要不停的入辅助栈，直到没有元素可用 while (s.empty() || s.top() != v_2[index_2]) &#123; if (index_1 &lt; v_1.size()) s.push(v_1[index_1++]); else return false; //将v_1中数据全部入栈，还是没有在v_2中发现有相等的，说明，两个序列含有的数据不一样 &#125; //此时，s.top()=v_2[index_2]，说明原栈此处有出栈操作，得到v_2中的v_2[index]。 s.pop(); ++index_2; &#125; if (s.empty()) return true; else return false;&#125; 实验实例： 123456789101112131415161718192021int main()&#123; vector&lt;int&gt; v1 = &#123; 1,2,3,4,5 &#125;; vector&lt;int&gt; v2 = &#123; 4,5,3,2,1 &#125;; vector&lt;int&gt; v3 = &#123; 4,5,2,3,1 &#125;; cout &lt;&lt; &quot;v1 与 v2是否满足出栈、入栈的合法性？&quot;; if (Check_Out_Stack_Order(v1, v2)) cout &lt;&lt; &quot; 满足&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;不满足&quot; &lt;&lt; endl; cout &lt;&lt; &quot;v1 与 v3是否满足出栈、入栈的合法性？&quot;; if (Check_Out_Stack_Order(v1, v3)) cout &lt;&lt; &quot; 满足&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;不满足&quot; &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125;","tags":[]},{"title":"C++小知识点小总结","date":"2017-04-12T15:02:58.000Z","path":"2017/04/12/C++小知识点小总结/","text":"本着食之无味，弃之可惜的思想，本文简单总结一些在博客中没有写到或者知识点较简单的内容，方便日后查看。欢迎大家补充（持续更新）声明与定义：变量的声明同时也是定义。只有extern int a这种情况下是声明。函数才分声明（原型）和定义（实现）。作用域：1，局部2，全局3，命名空间4，类访问命名空间中的成员比如命名空间N1中有Fun()函数1，N1::Fun();2，using namespace N1;3，using namespace N1::Fun();内存分配（地址由高到低）1. 栈又叫堆栈，非静态局部变量/函数参数/返回&#20540;等等，栈是向下增长的。2. 内存映射段是高效的I/O映射方式，用于装载一个共享的动态内存库。用户可使用系统接口创建共享共享内存，做进程间通信。3. 堆用于程序运行时动态内存分配，堆是可以上增长的。4. 数据段–存储全局数据和静态数据。5. 代码段–可执行的代码/只读常量。typedef关键字(类型别名)数组：typedef int ARRY_INT[10];函数指针：typedef void (Fun)(int a);引用（实体别名）数组引用：int a[10] = {0};int (&amp;ra)[10] &nbsp;= a;参数与返回&#20540;1，参数：三种传递方式：传&#20540;、传指针、传引用。根据功能还可分为：（1）输入型参数：不会改变传入实参的内容（传&#20540;，带const的传指针，带const的传引用）。（2）输出型参数：会.改变传入实参的内容（不带const的传指针，不带const的传引用）。2，返回&#20540;：（1）无返回&#20540;（2）临时变量：返回一个用完就销毁的&#20540;。 &nbsp; &nbsp;（3）引用（或指针）：主要支持链式赋&#20540;的操作。一般来说，对于const顶层const：任意对象都是常量。底层const：指针或引用所指的对象是一个常量。指针类型即可以是顶层cosnt，又可以是底层const。const int const p = &amp;a;&nbsp;空类大小为了区分不同的类，使他们在内存中的偏移不同，编译器会在空类中自己添加一个char成本变量，使得空类大小变为1.编译器如何辨认一个类1，识别类名2，识别类名成员变量3，识别类名成员函数，并进行改写类的哪些成员变量必须在初始化列表中初始化1，引用2，带const修饰符的变量（常变量）。3，将某一类作为成员，且该类的构造函数有参数且不是全缺省。4，如果存在继承，则必须在初始化列表中调用基类构造函数构造函数有没有返回&#20540;？严&#26684;来说，在调用后，函数给编译器返回了一个&#20540;。只是我们在编写时，无法给出一个返回&#20540;。访问类中的私有成员变量1，公有成员函数2，类的友元函数3，利用类的基地址偏移。offset(s, m)宏((size_t) &amp;((s *)0)-&gt;m)","tags":[]},{"title":"this指针详解","date":"2017-04-12T14:41:36.000Z","path":"2017/04/12/this指针详解/","text":"我们知道在如下例子中。class Test{public: Fun(int a) { //doSomething }private: int a;};Fun(int a)是Test的非静态成员函数，所以编译器在编译期间改写该函数时，会自动将一个名为this的指针当作为第一个参数传入。类&#20284;于：Fun(Test const this，int a);那么问题来了，我们理解这个this指针呢？它有哪些用法和限制呢？本文试图通过如下几个模块循环渐进的解析this指针，争取达到深入浅出的效果。1，this指针是什么？2，this指针的六大属性。3，this指针的一些用法。4，this指针的注意事项。1，this指针是什么？关于this指针超级经典的一段话：当你进入一个房子后， 你可以看见桌子、椅子、地板等， 但是房子你是看不到全貌了。 对于一个类的实例来说， 你可以看到它的成员函数、成员变量， 但是实例本身呢？ this是一个指针，它时时刻刻指向你这个实例本身。2，this指针的六大属性。我一直都认为若想对某一变量有个准确的认知，就必须了解其六大属性。（我的以前博客中有所介绍点击打开链接）这些属性是我们对于this指针应该以何种方式正确使用的基础。（1）名称属性：标识符this表示。（2）类型属性：类类型 const（类&#20284;于类引用的类型）（3）&#20540;属性：表示当前调用该函数对象的首地址。（4）作用域：this指针是编译器默认传给类中非静态函数的隐含形参，所以其作用域在非静态成员函数的函数体内。（5）链接属性：在该类作用域中，不同类的非静态成员函数中，this这个指针变量的链接属性是内部的，但其所指对象是外部的，即this变量是不同的实体，但指向对象是同一个。（6）存储类型：this指针是由编译器生成，当类的非静态成员函数的参数个数一定时，this指针存储在ecx寄存器中；若该函数参数个数未定（可变参数函数），则存放在栈中。3，this指针的一些用法。（1）作为当前类的指针，用来区别形参和成员变量名称相同的情况。比如本文开头的例子，在Test::Test(int a)函数的作用域中，形参a与类的成员变量a同名，则形参a会将成员变量a隐藏。我们无法直接访问成员变量a，除了在a前面加上类的名字如Test::a来表示类Test的成员变量a外，还可以显示使用this指针来强制访问对象成员this-&gt;a（2）this作为返回&#20540;，返回当前对象的引用。在赋&#20540;运算符重载函数中，为了不减少赋&#20540;运算符的功能，我们需要返回一个引用，来支持重复赋&#20540;（例如a = b =c;）同样，在类的赋&#20540;运算符重载函数中，我们可以一般使用(this)作为当前对象返回。4，this指针的注意事项。（1）this指针不能为空。因为this指向一个已存在的类的实例对象，可以通过&quot;-&gt;&quot;的方式，访问类中成员，左移this为空是非法的。例如，在本文开头例子中，将成员变量a的访问权限改写为public，然后执行下面代码，虽然编译会通过，但程序运行会崩溃。 Test pT = NULL; pT-&gt;a = 10;（2）为什么使用的是指针，而不是引用。this指针的类型和类引用的类型都是Test* const但是，由于历史原因，C&#43;&#43;最初是没有引用，而有指针的，在设计类时，就采用了指针的方式，就导致了现在的局面。虽然引用理论上也可以实现this的功能。（3）this指针并不是对象的一部分，不影响sizeof的结果。（4）this指针是由编译器自动生成，作为函数的第一个参数，用户不能显示传递。（5）this指针不能在构造函数的初始化列表中给对象的成员变量赋&#20540;，初始化列表本义是在创建类的实例对象时，给其中成员变量赋初&#20540;。即此时对象还未创建完毕。而this指针是类在创建之后，由编译器自动生成的指针，指向对象的首地址。简单来说，先有对象，后有this指针。所以this指针不能在初始化列表中给成员指针赋初&#20540;。（6）关于this的存储及传参顺序当类的非静态成员函数的参数个数是一定时，this指针存储在ecx寄存器上，通过ecx传递给调用者，此时函数调用约定是_thiscall。若参数个数不确定（可变参数）时，则借助栈，在所有的参数被压栈后，再压入栈中，此时函数调用约定是_cdecl。示例：将Test类简化，只声明，不定义。（可以方便的观察函数的调用约定和函数名的改写）class Test{public: void Fun(int a);};其中，Fun(int a)的个数确定，只有一个。则链接时会报错：error LNK2019: 无法解析的外部符号 &quot;public: void thiscall Test::Fun(int)&quot; (?Fun@Test@@QAEXH@Z)，该符号在函数 _main 中被引用将void Fun(int a);改为void Fun(…);则链接时报错为：error LNK2019: 无法解析的外部符号 &quot;public: void cdecl Test::Fun(…)&quot; (?Fun@Test@@QAAXZZ)，该符号在函数 _main 中被引用可以证明，当函数参数不同时，函数的调用约定不同，this的存储类型不同，造成了其传参顺序的不同。","tags":[]},{"title":"第一篇博客","date":"2017-04-10T09:12:49.000Z","path":"2017/04/10/第一篇博客/","text":"","tags":[]},{"title":"hello world2","date":"2017-04-09T13:51:32.000Z","path":"2017/04/09/hello-world2/","text":"","tags":[]},{"title":"hello world","date":"2017-04-09T13:51:00.000Z","path":"2017/04/09/hello-world-1/","text":"","tags":[]},{"title":"Hello World","date":"2017-04-09T12:53:22.938Z","path":"2017/04/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]